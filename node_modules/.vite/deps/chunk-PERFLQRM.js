// node_modules/@emotion/hash/dist/emotion-hash.esm.js
function murmur2(str) {
  var h = 0;
  var k, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
    k ^= /* k >>> r: */
    k >>> 24;
    h = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h ^= str.charCodeAt(i) & 255;
      h = /* Math.imul(h, m): */
      (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  h ^= h >>> 13;
  h = /* Math.imul(h, m): */
  (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  return ((h ^ h >>> 15) >>> 0).toString(36);
}

// node_modules/@webstudio-is/sdk/lib/runtime.js
var createJsonStringifyProxy = (target) => {
  return new Proxy(target, {
    get(target2, prop, receiver) {
      if (prop === "toString") {
        return function() {
          return JSON.stringify(target2);
        };
      }
      const value = Reflect.get(target2, prop, receiver);
      if (typeof value === "object" && value !== null) {
        return createJsonStringifyProxy(value);
      }
      return value;
    }
  });
};
var isPlainObject = (value) => {
  return Object.prototype.toString.call(value) === "[object Object]" && (Object.getPrototypeOf(value) === null || Object.getPrototypeOf(value) === Object.prototype);
};
var serializeValue = (value) => {
  if (typeof value === "string") {
    return value;
  }
  return JSON.stringify(value);
};
var LOCAL_RESOURCE_PREFIX = "$resources";
var isLocalResource = (pathname, resourceName) => {
  const segments = pathname.split("/").filter(Boolean);
  if (resourceName === void 0) {
    return segments[0] === LOCAL_RESOURCE_PREFIX;
  }
  return segments.join("/") === `${LOCAL_RESOURCE_PREFIX}/${resourceName}`;
};
var sitemapResourceUrl = `/${LOCAL_RESOURCE_PREFIX}/sitemap.xml`;
var loadResource = async (customFetch, resourceRequest) => {
  try {
    const { method, searchParams, headers, body } = resourceRequest;
    const url = new URL(resourceRequest.url.trim());
    if (searchParams) {
      for (const { name, value } of searchParams) {
        url.searchParams.append(name, serializeValue(value));
      }
    }
    const requestHeaders = new Headers(
      headers.map(({ name, value }) => [
        name,
        serializeValue(value)
      ])
    );
    const requestInit = {
      method,
      headers: requestHeaders
    };
    if (method !== "get" && body !== void 0) {
      requestInit.body = serializeValue(body);
    }
    const response = await customFetch(url.href, requestInit);
    let data = await response.text();
    try {
      data = JSON.parse(data);
    } catch {
    }
    if (!response.ok) {
      console.error(
        `Failed to load resource: ${url} - ${response.status}: ${JSON.stringify(data).slice(0, 300)}`
      );
    }
    return {
      ok: response.ok,
      status: response.status,
      statusText: response.statusText,
      data
    };
  } catch (error) {
    console.error(error);
    const message = error.message;
    return {
      ok: false,
      data: void 0,
      status: 500,
      statusText: message
    };
  }
};
var loadResources = async (customFetch, requests) => {
  return Object.fromEntries(
    await Promise.all(
      Array.from(
        requests,
        async ([name, request]) => [name, await loadResource(customFetch, request)]
      )
    )
  );
};
var getCacheKey = async (request) => {
  const url = new URL(request.url);
  const method = request.method;
  const body = await request.clone().text();
  const cacheControl = request.headers.get("Cache-Control");
  const resourceHash = murmur2(`${method}:${body}:${cacheControl}`);
  url.searchParams.set("ws-resource-hash", resourceHash);
  return url;
};
var cachedFetch = async (namespace, input, init) => {
  if (globalThis.caches) {
    const request = new Request(input, init);
    const requestCacheControl = request.headers.get("Cache-Control");
    if (!requestCacheControl) {
      return fetch(input, init);
    }
    const cache = await caches.open(namespace);
    const cacheKey = await getCacheKey(request);
    let response = await cache.match(cacheKey);
    if (response) {
      return new Response(response.body, response);
    }
    response = await fetch(request);
    if (!response.ok) {
      return response;
    }
    response = new Response(response.body, response);
    response.headers.set("Cache-Control", requestCacheControl);
    await cache.put(cacheKey, response.clone());
    return response;
  }
  return fetch(input, init);
};
var formIdFieldName = `ws--form-id`;
var formBotFieldName = `ws--form-bot`;
var tagProperty = "data-ws-tag";
var getTagFromProps = (props) => {
  return props[tagProperty];
};
var indexProperty = "data-ws-index";
var getIndexWithinAncestorFromProps = (props) => {
  return props[indexProperty];
};
var animationCanPlayOnCanvasProperty = "data-ws-animation-can-play-on-canvas";

export {
  createJsonStringifyProxy,
  isPlainObject,
  serializeValue,
  isLocalResource,
  sitemapResourceUrl,
  loadResource,
  loadResources,
  cachedFetch,
  formIdFieldName,
  formBotFieldName,
  tagProperty,
  getTagFromProps,
  indexProperty,
  getIndexWithinAncestorFromProps,
  animationCanPlayOnCanvasProperty
};
//# sourceMappingURL=chunk-PERFLQRM.js.map
