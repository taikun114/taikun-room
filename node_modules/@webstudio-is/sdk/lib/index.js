var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/schema/assets.ts
import { z } from "zod";
import { FontFormat, FontMeta } from "@webstudio-is/fonts";
var AssetId = z.string();
var baseAsset = {
  id: AssetId,
  projectId: z.string(),
  size: z.number(),
  name: z.string(),
  filename: z.string().optional(),
  description: z.union([z.string().optional(), z.null()]),
  createdAt: z.string()
};
var FontAsset = z.object({
  ...baseAsset,
  format: FontFormat,
  meta: FontMeta,
  type: z.literal("font")
});
var ImageMeta = z.object({
  width: z.number(),
  height: z.number()
});
var ImageAsset = z.object({
  ...baseAsset,
  format: z.string(),
  meta: ImageMeta,
  type: z.literal("image")
});
var Asset = z.union([FontAsset, ImageAsset]);
var Assets = z.map(AssetId, Asset);

// src/schema/pages.ts
import { z as z2 } from "zod";
var MIN_TITLE_LENGTH = 2;
var PageId = z2.string();
var FolderId = z2.string();
var FolderName = z2.string().refine((value) => value.trim() !== "", "Can't be empty");
var Slug = z2.string().refine(
  (path) => /^[-a-z0-9]*$/.test(path),
  "Only a-z, 0-9 and - are allowed"
);
var Folder = z2.object({
  id: FolderId,
  name: FolderName,
  slug: Slug,
  children: z2.array(z2.union([FolderId, PageId]))
});
var PageName = z2.string().refine((value) => value.trim() !== "", "Can't be empty");
var PageTitle = z2.string().refine(
  (val) => val.length >= MIN_TITLE_LENGTH,
  `Minimum ${MIN_TITLE_LENGTH} characters required`
);
var documentTypes = ["html", "xml"];
var commonPageFields = {
  id: PageId,
  name: PageName,
  title: PageTitle,
  history: z2.optional(z2.array(z2.string())),
  rootInstanceId: z2.string(),
  systemDataSourceId: z2.string().optional(),
  meta: z2.object({
    description: z2.string().optional(),
    title: z2.string().optional(),
    excludePageFromSearch: z2.string().optional(),
    language: z2.string().optional(),
    socialImageAssetId: z2.string().optional(),
    socialImageUrl: z2.string().optional(),
    status: z2.string().optional(),
    redirect: z2.string().optional(),
    documentType: z2.optional(z2.enum(documentTypes)),
    custom: z2.array(
      z2.object({
        property: z2.string(),
        content: z2.string()
      })
    ).optional()
  }),
  marketplace: z2.optional(
    z2.object({
      include: z2.optional(z2.boolean()),
      category: z2.optional(z2.string()),
      thumbnailAssetId: z2.optional(z2.string())
    })
  )
};
var HomePagePath = z2.string().refine((path) => path === "", "Home page path must be empty");
var HomePage = z2.object({
  ...commonPageFields,
  path: HomePagePath
});
var DefaultPagePage = z2.string().refine((path) => path !== "", "Can't be empty").refine((path) => path !== "/", "Can't be just a /").refine((path) => path.endsWith("/") === false, "Can't end with a /").refine((path) => path.includes("//") === false, "Can't contain repeating /").refine(
  (path) => /^[-_a-z0-9*:?\\/.]*$/.test(path),
  "Only a-z, 0-9, -, _, /, :, ?, . and * are allowed"
).refine(
  // We use /s for our system stuff like /s/css or /s/uploads
  (path) => path !== "/s" && path.startsWith("/s/") === false,
  "/s prefix is reserved for the system"
).refine(
  // Remix serves build artefacts like JS bundles from /build
  // And we cannot customize it due to bug in Remix: https://github.com/remix-run/remix/issues/2933
  (path) => path !== "/build" && path.startsWith("/build/") === false,
  "/build prefix is reserved for the system"
);
var OldPagePath = z2.string().refine((path) => path !== "", "Can't be empty").refine((path) => path !== "/", "Can't be just a /").refine(
  (path) => path === "" || path.startsWith("/"),
  "Must start with a / or a full URL e.g. https://website.org"
).refine((path) => path.endsWith("/") === false, "Can't end with a /").refine((path) => path.includes("//") === false, "Can't contain repeating /").refine(
  (path) => /^[-_a-zA-Z0-9*:?\\/.]*$/.test(path),
  // Allow uppercase letters (A-Z)
  "Only a-z, A-Z, 0-9, -, _, /, :, ?, . and * are allowed"
).refine(
  (path) => path !== "/s" && path.startsWith("/s/") === false,
  "/s prefix is reserved for the system"
).refine(
  (path) => path !== "/build" && path.startsWith("/build/") === false,
  "/build prefix is reserved for the system"
);
var PagePath = DefaultPagePage.refine(
  (path) => path === "" || path.startsWith("/"),
  "Must start with a / or a full URL e.g. https://website.org"
);
var Page = z2.object({
  ...commonPageFields,
  path: PagePath
});
var ProjectMeta = z2.object({
  // All fields are optional to ensure consistency and allow for the addition of new fields without requiring migration
  siteName: z2.string().optional(),
  contactEmail: z2.string().optional(),
  faviconAssetId: z2.string().optional(),
  code: z2.string().optional()
});
var ProjectNewRedirectPath = z2.string().refine((data) => {
  try {
    new URL(data, "http://url.com");
    return true;
  } catch {
    return false;
  }
}, "Must be a valid URL");
var PageRedirect = z2.object({
  old: OldPagePath,
  new: ProjectNewRedirectPath,
  status: z2.enum(["301", "302"]).optional()
});
var CompilerSettings = z2.object({
  // All fields are optional to ensure consistency and allow for the addition of new fields without requiring migration
  atomicStyles: z2.boolean().optional()
});
var Pages = z2.object({
  meta: ProjectMeta.optional(),
  compiler: CompilerSettings.optional(),
  redirects: z2.array(PageRedirect).optional(),
  homePage: HomePage,
  pages: z2.array(Page),
  folders: z2.array(Folder).refine((folders) => folders.length > 0, "Folders can't be empty")
});

// src/schema/instances.ts
import { z as z3 } from "zod";
var TextChild = z3.object({
  type: z3.literal("text"),
  value: z3.string(),
  placeholder: z3.boolean().optional()
});
var InstanceId = z3.string();
var IdChild = z3.object({
  type: z3.literal("id"),
  value: InstanceId
});
var ExpressionChild = z3.object({
  type: z3.literal("expression"),
  value: z3.string()
});
var InstanceChild = z3.union([IdChild, TextChild, ExpressionChild]);
var Instance = z3.object({
  type: z3.literal("instance"),
  id: InstanceId,
  component: z3.string(),
  tag: z3.string().optional(),
  label: z3.string().optional(),
  children: z3.array(InstanceChild)
});
var Instances = z3.map(InstanceId, Instance);

// src/schema/data-sources.ts
import { z as z4 } from "zod";
var DataSourceId = z4.string();
var DataSourceVariableValue = z4.union([
  z4.object({
    type: z4.literal("number"),
    // initial value of variable store
    value: z4.number()
  }),
  z4.object({
    type: z4.literal("string"),
    value: z4.string()
  }),
  z4.object({
    type: z4.literal("boolean"),
    value: z4.boolean()
  }),
  z4.object({
    type: z4.literal("string[]"),
    value: z4.array(z4.string())
  }),
  z4.object({
    type: z4.literal("json"),
    value: z4.unknown()
  })
]);
var DataSource = z4.union([
  z4.object({
    type: z4.literal("variable"),
    id: DataSourceId,
    // The instance should always be specified for variables,
    // however, there was a bug in the embed template
    // which produced variables without an instance
    // and these variables will fail validation
    // if we make it required
    scopeInstanceId: z4.string().optional(),
    name: z4.string(),
    value: DataSourceVariableValue
  }),
  z4.object({
    type: z4.literal("parameter"),
    id: DataSourceId,
    scopeInstanceId: z4.string().optional(),
    name: z4.string()
  }),
  z4.object({
    type: z4.literal("resource"),
    id: DataSourceId,
    scopeInstanceId: z4.string().optional(),
    name: z4.string(),
    resourceId: z4.string()
  })
]);
var DataSources = z4.map(DataSourceId, DataSource);

// src/schema/resources.ts
import { z as z5 } from "zod";
var ResourceId = z5.string();
var Method = z5.union([
  z5.literal("get"),
  z5.literal("post"),
  z5.literal("put"),
  z5.literal("delete")
]);
var Resource = z5.object({
  id: ResourceId,
  name: z5.string(),
  control: z5.optional(z5.union([z5.literal("system"), z5.literal("graphql")])),
  method: Method,
  // expression
  url: z5.string(),
  searchParams: z5.array(
    z5.object({
      name: z5.string(),
      // expression
      value: z5.string()
    })
  ).optional(),
  headers: z5.array(
    z5.object({
      name: z5.string(),
      // expression
      value: z5.string()
    })
  ),
  // expression
  body: z5.optional(z5.string())
});
var ResourceRequest = z5.object({
  name: z5.string(),
  method: Method,
  url: z5.string(),
  searchParams: z5.array(
    z5.object({
      name: z5.string(),
      // can be string or object which should be serialized
      value: z5.unknown()
    })
  ),
  headers: z5.array(
    z5.object({
      name: z5.string(),
      // can be string or object which should be serialized
      value: z5.unknown()
    })
  ),
  body: z5.optional(z5.unknown())
});
var Resources = z5.map(ResourceId, Resource);

// src/schema/props.ts
import { z as z7 } from "zod";

// src/schema/animation-schema.ts
import { StyleValue } from "@webstudio-is/css-engine";
import { z as z6 } from "zod";
var literalUnion = (arr) => z6.union(
  arr.map((val) => z6.literal(val))
);
var RANGE_UNITS = [
  "%",
  "px",
  "cm",
  "mm",
  "q",
  "in",
  "pt",
  "pc",
  "em",
  "rem",
  "ex",
  "rex",
  "cap",
  "rcap",
  "ch",
  "rch",
  "lh",
  "rlh",
  "vw",
  "svw",
  "lvw",
  "dvw",
  "vh",
  "svh",
  "lvh",
  "dvh",
  "vi",
  "svi",
  "lvi",
  "dvi",
  "vb",
  "svb",
  "lvb",
  "dvb",
  "vmin",
  "svmin",
  "lvmin",
  "dvmin",
  "vmax",
  "svmax",
  "lvmax",
  "dvmax"
];
var rangeUnitSchema = literalUnion(RANGE_UNITS);
var rangeUnitValueSchema = z6.union([
  z6.object({
    type: z6.literal("unit"),
    value: z6.number(),
    unit: rangeUnitSchema
  }),
  z6.object({
    type: z6.literal("unparsed"),
    value: z6.string()
  }),
  z6.object({
    type: z6.literal("var"),
    value: z6.string()
  })
]);
var TIME_UNITS = ["ms", "s"];
var timeUnitSchema = literalUnion(TIME_UNITS);
var durationUnitValueSchema = z6.union([
  z6.object({
    type: z6.literal("unit"),
    value: z6.number(),
    unit: timeUnitSchema
  }),
  z6.object({
    type: z6.literal("var"),
    value: z6.string()
  })
]);
var insetUnitValueSchema = z6.union([
  rangeUnitValueSchema,
  z6.object({
    type: z6.literal("keyword"),
    value: z6.literal("auto")
  })
]);
var keyframeStylesSchema = z6.record(StyleValue);
var animationKeyframeSchema = z6.object({
  offset: z6.number().optional(),
  styles: keyframeStylesSchema
});
var keyframeEffectOptionsSchema = z6.object({
  easing: z6.string().optional(),
  fill: z6.union([
    z6.literal("none"),
    z6.literal("forwards"),
    z6.literal("backwards"),
    z6.literal("both")
  ]).optional(),
  // FillMode
  duration: durationUnitValueSchema.optional()
});
var scrollNamedRangeSchema = z6.union([
  z6.literal("start"),
  z6.literal("end")
]);
var scrollRangeValueSchema = z6.tuple([
  scrollNamedRangeSchema,
  rangeUnitValueSchema
]);
var scrollRangeOptionsSchema = z6.object({
  rangeStart: scrollRangeValueSchema.optional(),
  rangeEnd: scrollRangeValueSchema.optional()
});
var animationAxisSchema = z6.union([
  z6.literal("block"),
  z6.literal("inline"),
  z6.literal("x"),
  z6.literal("y")
]);
var viewNamedRangeSchema = z6.union([
  z6.literal("contain"),
  z6.literal("cover"),
  z6.literal("entry"),
  z6.literal("exit"),
  z6.literal("entry-crossing"),
  z6.literal("exit-crossing")
]);
var viewRangeValueSchema = z6.tuple([
  viewNamedRangeSchema,
  rangeUnitValueSchema
]);
var viewRangeOptionsSchema = z6.object({
  rangeStart: viewRangeValueSchema.optional(),
  rangeEnd: viewRangeValueSchema.optional()
});
var baseAnimation = z6.object({
  name: z6.string().optional(),
  description: z6.string().optional(),
  enabled: z6.array(z6.tuple([z6.string().describe("breakpointId"), z6.boolean()])).optional(),
  keyframes: z6.array(animationKeyframeSchema)
});
var scrollAnimationSchema = baseAnimation.merge(
  z6.object({
    timing: keyframeEffectOptionsSchema.merge(scrollRangeOptionsSchema)
  })
);
var scrollActionSchema = z6.object({
  type: z6.literal("scroll"),
  source: z6.union([z6.literal("closest"), z6.literal("nearest"), z6.literal("root")]).optional(),
  axis: animationAxisSchema.optional(),
  animations: z6.array(scrollAnimationSchema),
  isPinned: z6.boolean().optional(),
  debug: z6.boolean().optional()
});
var viewAnimationSchema = baseAnimation.merge(
  z6.object({
    timing: keyframeEffectOptionsSchema.merge(viewRangeOptionsSchema)
  })
);
var viewActionSchema = z6.object({
  type: z6.literal("view"),
  subject: z6.string().optional(),
  axis: animationAxisSchema.optional(),
  animations: z6.array(viewAnimationSchema),
  insetStart: insetUnitValueSchema.optional(),
  insetEnd: insetUnitValueSchema.optional(),
  isPinned: z6.boolean().optional(),
  debug: z6.boolean().optional()
});
var animationActionSchema = z6.discriminatedUnion("type", [
  scrollActionSchema,
  viewActionSchema
]);

// src/schema/props.ts
var PropId = z7.string();
var baseProp = {
  id: PropId,
  instanceId: z7.string(),
  name: z7.string(),
  required: z7.optional(z7.boolean())
};
var Prop = z7.union([
  z7.object({
    ...baseProp,
    type: z7.literal("number"),
    value: z7.number()
  }),
  z7.object({
    ...baseProp,
    type: z7.literal("string"),
    value: z7.string()
  }),
  z7.object({
    ...baseProp,
    type: z7.literal("boolean"),
    value: z7.boolean()
  }),
  z7.object({
    ...baseProp,
    type: z7.literal("json"),
    value: z7.unknown()
  }),
  z7.object({
    ...baseProp,
    type: z7.literal("asset"),
    value: z7.string()
    // asset id
  }),
  z7.object({
    ...baseProp,
    type: z7.literal("page"),
    value: z7.union([
      z7.string(),
      // page id
      z7.object({
        pageId: z7.string(),
        instanceId: z7.string()
      })
    ])
  }),
  z7.object({
    ...baseProp,
    type: z7.literal("string[]"),
    value: z7.array(z7.string())
  }),
  z7.object({
    ...baseProp,
    type: z7.literal("parameter"),
    // data source id
    value: z7.string()
  }),
  z7.object({
    ...baseProp,
    type: z7.literal("resource"),
    // resource id
    value: z7.string()
  }),
  z7.object({
    ...baseProp,
    type: z7.literal("expression"),
    // expression code
    value: z7.string()
  }),
  z7.object({
    ...baseProp,
    type: z7.literal("action"),
    value: z7.array(
      z7.object({
        type: z7.literal("execute"),
        args: z7.array(z7.string()),
        code: z7.string()
      })
    )
  }),
  z7.object({
    ...baseProp,
    type: z7.literal("animationAction"),
    value: animationActionSchema
  })
]);
var Props = z7.map(PropId, Prop);

// src/schema/breakpoints.ts
import { z as z8 } from "zod";
var BreakpointId = z8.string();
var Breakpoint = z8.object({
  id: BreakpointId,
  label: z8.string(),
  minWidth: z8.number().optional(),
  maxWidth: z8.number().optional()
}).refine(({ minWidth, maxWidth }) => {
  return (
    // Either min or max width have to be defined
    minWidth !== void 0 && maxWidth === void 0 || minWidth === void 0 && maxWidth !== void 0 || // This is a base breakpoint
    minWidth === void 0 && maxWidth === void 0
  );
}, "Either minWidth or maxWidth should be defined");
var Breakpoints = z8.map(BreakpointId, Breakpoint);
var initialBreakpoints = [
  { id: "placeholder", label: "Base" },
  { id: "placeholder", label: "Tablet", maxWidth: 991 },
  { id: "placeholder", label: "Mobile landscape", maxWidth: 767 },
  { id: "placeholder", label: "Mobile portrait", maxWidth: 479 }
];

// src/schema/style-sources.ts
import { z as z9 } from "zod";
var StyleSourceId = z9.string();
var StyleSourceToken = z9.object({
  type: z9.literal("token"),
  id: StyleSourceId,
  name: z9.string()
});
var StyleSourceLocal = z9.object({
  type: z9.literal("local"),
  id: StyleSourceId
});
var StyleSource = z9.union([StyleSourceToken, StyleSourceLocal]);
var StyleSources = z9.map(StyleSourceId, StyleSource);

// src/schema/style-source-selections.ts
import { z as z10 } from "zod";
var InstanceId2 = z10.string();
var StyleSourceId2 = z10.string();
var StyleSourceSelection = z10.object({
  instanceId: InstanceId2,
  values: z10.array(StyleSourceId2)
});
var StyleSourceSelections = z10.map(InstanceId2, StyleSourceSelection);

// src/schema/styles.ts
import { z as z11 } from "zod";
import { StyleValue as StyleValue2 } from "@webstudio-is/css-engine";
var StyleDeclRaw = z11.object({
  styleSourceId: z11.string(),
  breakpointId: z11.string(),
  state: z11.optional(z11.string()),
  // @todo can't figure out how to make property to be enum
  property: z11.string(),
  value: StyleValue2,
  listed: z11.boolean().optional().describe("Whether the style is from the Advanced panel")
});
var StyleDecl = StyleDeclRaw;
var getStyleDeclKey = (styleDecl) => {
  return `${styleDecl.styleSourceId}:${styleDecl.breakpointId}:${styleDecl.property}:${styleDecl.state ?? ""}`;
};
var Styles = z11.map(z11.string(), StyleDecl);

// src/schema/deployment.ts
import { z as z12 } from "zod";
var Templates = z12.enum([
  "docker",
  "vercel",
  "netlify",
  "ssg",
  "ssg-netlify",
  "ssg-vercel"
]);
var Deployment = z12.union([
  z12.object({
    destination: z12.literal("static"),
    name: z12.string(),
    assetsDomain: z12.string(),
    // Must be validated very strictly
    templates: z12.array(Templates)
  }),
  z12.object({
    destination: z12.literal("saas").optional(),
    domains: z12.array(z12.string()),
    assetsDomain: z12.string().optional(),
    /**
     * @deprecated This field is deprecated, use `domains` instead.
     */
    projectDomain: z12.string().optional(),
    excludeWstdDomainFromSearch: z12.boolean().optional()
  })
]);

// src/schema/webstudio.ts
import { z as z13 } from "zod";
var WebstudioFragment = z13.object({
  children: z13.array(InstanceChild),
  instances: z13.array(Instance),
  assets: z13.array(Asset),
  dataSources: z13.array(DataSource),
  resources: z13.array(Resource),
  props: z13.array(Prop),
  breakpoints: z13.array(Breakpoint),
  styleSourceSelections: z13.array(StyleSourceSelection),
  styleSources: z13.array(StyleSource),
  styles: z13.array(StyleDecl)
});

// src/schema/prop-meta.ts
import { z as z14 } from "zod";
var common = {
  label: z14.string().optional(),
  description: z14.string().optional(),
  required: z14.boolean()
};
var Tag = z14.object({
  ...common,
  control: z14.literal("tag"),
  type: z14.literal("string"),
  defaultValue: z14.undefined().optional(),
  options: z14.array(z14.string())
});
var Number = z14.object({
  ...common,
  control: z14.literal("number"),
  type: z14.literal("number"),
  defaultValue: z14.number().optional()
});
var Range = z14.object({
  ...common,
  control: z14.literal("range"),
  type: z14.literal("number"),
  defaultValue: z14.number().optional()
});
var Text = z14.object({
  ...common,
  control: z14.literal("text"),
  type: z14.literal("string"),
  defaultValue: z14.string().optional(),
  /**
   * The number of rows in <textarea>. If set to 0 an <input> will be used instead.
   * In line with Storybook team's plan: https://github.com/storybookjs/storybook/issues/21100
   */
  rows: z14.number().optional()
});
var Resource2 = z14.object({
  ...common,
  control: z14.literal("resource"),
  type: z14.literal("resource"),
  defaultValue: z14.string().optional()
});
var Code = z14.object({
  ...common,
  control: z14.literal("code"),
  type: z14.literal("string"),
  language: z14.union([z14.literal("html"), z14.literal("markdown")]),
  defaultValue: z14.string().optional()
});
var CodeText = z14.object({
  ...common,
  control: z14.literal("codetext"),
  type: z14.literal("string"),
  defaultValue: z14.string().optional()
});
var Color = z14.object({
  ...common,
  control: z14.literal("color"),
  type: z14.literal("string"),
  defaultValue: z14.string().optional()
});
var Boolean = z14.object({
  ...common,
  control: z14.literal("boolean"),
  type: z14.literal("boolean"),
  defaultValue: z14.boolean().optional()
});
var Radio = z14.object({
  ...common,
  control: z14.literal("radio"),
  type: z14.literal("string"),
  defaultValue: z14.string().optional(),
  options: z14.array(z14.string())
});
var InlineRadio = z14.object({
  ...common,
  control: z14.literal("inline-radio"),
  type: z14.literal("string"),
  defaultValue: z14.string().optional(),
  options: z14.array(z14.string())
});
var Select = z14.object({
  ...common,
  control: z14.literal("select"),
  type: z14.literal("string"),
  defaultValue: z14.string().optional(),
  options: z14.array(z14.string())
});
var Check = z14.object({
  ...common,
  control: z14.literal("check"),
  type: z14.literal("string[]"),
  defaultValue: z14.array(z14.string()).optional(),
  options: z14.array(z14.string())
});
var InlineCheck = z14.object({
  ...common,
  control: z14.literal("inline-check"),
  type: z14.literal("string[]"),
  defaultValue: z14.array(z14.string()).optional(),
  options: z14.array(z14.string())
});
var MultiSelect = z14.object({
  ...common,
  control: z14.literal("multi-select"),
  type: z14.literal("string[]"),
  defaultValue: z14.array(z14.string()).optional(),
  options: z14.array(z14.string())
});
var File = z14.object({
  ...common,
  control: z14.literal("file"),
  type: z14.literal("string"),
  defaultValue: z14.string().optional(),
  /** https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file#accept */
  accept: z14.string().optional()
});
var Url = z14.object({
  ...common,
  control: z14.literal("url"),
  type: z14.literal("string"),
  defaultValue: z14.string().optional()
});
var Json = z14.object({
  ...common,
  control: z14.literal("json"),
  type: z14.literal("json"),
  defaultValue: z14.unknown().optional()
});
var Date = z14.object({
  ...common,
  control: z14.literal("date"),
  // @todo not sure what type should be here
  // (we don't support Date yet, added for completeness)
  type: z14.literal("string"),
  defaultValue: z14.string().optional()
});
var Action = z14.object({
  ...common,
  control: z14.literal("action"),
  type: z14.literal("action"),
  defaultValue: z14.undefined().optional()
});
var TextContent = z14.object({
  ...common,
  control: z14.literal("textContent"),
  type: z14.literal("string"),
  defaultValue: z14.string().optional()
});
var AnimationAction = z14.object({
  ...common,
  control: z14.literal("animationAction"),
  type: z14.literal("animationAction"),
  defaultValue: z14.undefined().optional()
});
var PropMeta = z14.union([
  Tag,
  Number,
  Range,
  Text,
  Resource2,
  Code,
  CodeText,
  Color,
  Boolean,
  Radio,
  InlineRadio,
  Select,
  MultiSelect,
  Check,
  InlineCheck,
  File,
  Url,
  Json,
  Date,
  Action,
  TextContent,
  AnimationAction
]);

// src/schema/component-meta.ts
import { z as z15 } from "zod";
import { StyleValue as StyleValue3 } from "@webstudio-is/css-engine";
var PresetStyleDecl = z15.object({
  // State selector, e.g. :hover
  state: z15.optional(z15.string()),
  property: z15.string(),
  value: StyleValue3
});
var componentCategories = [
  "general",
  "typography",
  "media",
  "animations",
  "data",
  "forms",
  "localization",
  "radix",
  "xml",
  "other",
  "hidden",
  "internal"
];
var ComponentState = z15.object({
  selector: z15.string(),
  label: z15.string()
});
var ComponentContent = z15.string();
var ContentModel = z15.object({
  /*
   * instance - accepted by any parent with "instance" in children categories
   * none - accepted by parents with this component name in children categories
   */
  category: z15.union([z15.literal("instance"), z15.literal("none")]),
  /**
   * enforce direct children of category or components
   */
  children: z15.array(ComponentContent),
  /**
   * enforce descendants of category or components
   */
  descendants: z15.array(ComponentContent).optional()
});
var WsComponentMeta = z15.object({
  category: z15.enum(componentCategories).optional(),
  contentModel: ContentModel.optional(),
  // when this field is specified component receives
  // prop with index of same components withiin specified ancestor
  // important to automatically enumerate collections without
  // naming every item manually
  indexWithinAncestor: z15.optional(z15.string()),
  label: z15.optional(z15.string()),
  description: z15.string().optional(),
  icon: z15.string().optional(),
  presetStyle: z15.optional(z15.record(z15.string(), z15.array(PresetStyleDecl))),
  states: z15.optional(z15.array(ComponentState)),
  order: z15.number().optional(),
  // properties and html attributes that will be always visible in properties panel
  initialProps: z15.array(z15.string()).optional(),
  props: z15.record(PropMeta).optional()
});

// src/core-metas.ts
import {
  ContentBlockIcon,
  ListViewIcon,
  PaintBrushIcon,
  SettingsIcon,
  AddTemplateInstanceIcon
} from "@webstudio-is/icons/svg";

// src/__generated__/normalize.css.ts
var normalize_css_exports = {};
__export(normalize_css_exports, {
  a: () => a,
  address: () => address,
  article: () => article,
  aside: () => aside,
  b: () => b,
  body: () => body,
  button: () => button,
  checkbox: () => checkbox,
  code: () => code,
  div: () => div,
  figure: () => figure,
  footer: () => footer,
  form: () => form,
  h1: () => h1,
  h2: () => h2,
  h3: () => h3,
  h4: () => h4,
  h5: () => h5,
  h6: () => h6,
  header: () => header,
  hr: () => hr,
  html: () => html,
  i: () => i,
  img: () => img,
  input: () => input,
  kbd: () => kbd,
  label: () => label,
  legend: () => legend,
  li: () => li,
  main: () => main,
  nav: () => nav,
  ol: () => ol,
  optgroup: () => optgroup,
  p: () => p,
  pre: () => pre,
  progress: () => progress,
  radio: () => radio,
  samp: () => samp,
  section: () => section,
  select: () => select,
  small: () => small,
  span: () => span,
  strong: () => strong,
  sub: () => sub,
  summary: () => summary,
  sup: () => sup,
  table: () => table,
  textarea: () => textarea,
  time: () => time,
  ul: () => ul
});
var div = [
  { property: "box-sizing", value: { type: "keyword", value: "border-box" } },
  {
    property: "border-top-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-right-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-bottom-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-left-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  { property: "outline-width", value: { type: "unit", unit: "px", value: 1 } }
];
var address = div;
var article = div;
var aside = div;
var figure = div;
var footer = div;
var header = div;
var main = div;
var nav = div;
var section = div;
var form = div;
var label = div;
var time = div;
var h1 = div;
var h2 = div;
var h3 = div;
var h4 = div;
var h5 = div;
var h6 = div;
var i = div;
var img = div;
var a = div;
var li = div;
var ul = div;
var ol = div;
var p = div;
var span = div;
var html = [
  { property: "display", value: { type: "keyword", value: "grid" } },
  { property: "min-height", value: { type: "unit", unit: "%", value: 100 } },
  {
    property: "font-family",
    value: { type: "fontFamily", value: ["Arial", "Roboto", "sans-serif"] }
  },
  { property: "font-size", value: { type: "unit", unit: "px", value: 16 } },
  {
    property: "line-height",
    value: { type: "unit", unit: "number", value: 1.2 }
  },
  {
    property: "white-space-collapse",
    value: { type: "keyword", value: "preserve" }
  }
];
var body = [
  { property: "margin-top", value: { type: "unit", unit: "number", value: 0 } },
  {
    property: "margin-right",
    value: { type: "unit", unit: "number", value: 0 }
  },
  {
    property: "margin-bottom",
    value: { type: "unit", unit: "number", value: 0 }
  },
  {
    property: "margin-left",
    value: { type: "unit", unit: "number", value: 0 }
  },
  { property: "box-sizing", value: { type: "keyword", value: "border-box" } },
  {
    property: "border-top-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-right-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-bottom-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-left-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "-webkit-font-smoothing",
    value: { type: "keyword", value: "antialiased" }
  },
  {
    property: "-moz-osx-font-smoothing",
    value: { type: "keyword", value: "grayscale" }
  }
];
var hr = [
  { property: "height", value: { type: "unit", unit: "number", value: 0 } },
  { property: "color", value: { type: "keyword", value: "inherit" } },
  { property: "box-sizing", value: { type: "keyword", value: "border-box" } }
];
var b = [
  {
    property: "font-weight",
    value: { type: "unit", unit: "number", value: 700 }
  },
  { property: "box-sizing", value: { type: "keyword", value: "border-box" } },
  {
    property: "border-top-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-right-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-bottom-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-left-width",
    value: { type: "unit", unit: "px", value: 1 }
  }
];
var strong = b;
var code = [
  {
    property: "font-family",
    value: {
      type: "fontFamily",
      value: [
        "ui-monospace",
        "SFMono-Regular",
        "Consolas",
        "Liberation Mono",
        "Menlo",
        "monospace"
      ]
    }
  },
  { property: "font-size", value: { type: "unit", unit: "em", value: 1 } },
  { property: "box-sizing", value: { type: "keyword", value: "border-box" } },
  {
    property: "border-top-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-right-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-bottom-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-left-width",
    value: { type: "unit", unit: "px", value: 1 }
  }
];
var kbd = code;
var samp = code;
var pre = code;
var small = [
  { property: "font-size", value: { type: "unit", unit: "%", value: 80 } },
  { property: "box-sizing", value: { type: "keyword", value: "border-box" } },
  {
    property: "border-top-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-right-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-bottom-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-left-width",
    value: { type: "unit", unit: "px", value: 1 }
  }
];
var sub = [
  { property: "font-size", value: { type: "unit", unit: "%", value: 75 } },
  {
    property: "line-height",
    value: { type: "unit", unit: "number", value: 0 }
  },
  { property: "position", value: { type: "keyword", value: "relative" } },
  { property: "vertical-align", value: { type: "keyword", value: "baseline" } },
  { property: "box-sizing", value: { type: "keyword", value: "border-box" } },
  {
    property: "border-top-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-right-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-bottom-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-left-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  { property: "bottom", value: { type: "unit", unit: "em", value: -0.25 } }
];
var sup = [
  { property: "font-size", value: { type: "unit", unit: "%", value: 75 } },
  {
    property: "line-height",
    value: { type: "unit", unit: "number", value: 0 }
  },
  { property: "position", value: { type: "keyword", value: "relative" } },
  { property: "vertical-align", value: { type: "keyword", value: "baseline" } },
  { property: "box-sizing", value: { type: "keyword", value: "border-box" } },
  {
    property: "border-top-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-right-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-bottom-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-left-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  { property: "top", value: { type: "unit", unit: "em", value: -0.5 } }
];
var table = [
  {
    property: "text-indent",
    value: { type: "unit", unit: "number", value: 0 }
  },
  {
    property: "border-top-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-right-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-bottom-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-left-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-top-color",
    value: { type: "keyword", value: "inherit" }
  },
  {
    property: "border-right-color",
    value: { type: "keyword", value: "inherit" }
  },
  {
    property: "border-bottom-color",
    value: { type: "keyword", value: "inherit" }
  },
  {
    property: "border-left-color",
    value: { type: "keyword", value: "inherit" }
  },
  { property: "box-sizing", value: { type: "keyword", value: "border-box" } }
];
var input = [
  { property: "font-family", value: { type: "keyword", value: "inherit" } },
  { property: "font-size", value: { type: "unit", unit: "%", value: 100 } },
  {
    property: "line-height",
    value: { type: "unit", unit: "number", value: 1.15 }
  },
  { property: "margin-top", value: { type: "unit", unit: "number", value: 0 } },
  {
    property: "margin-right",
    value: { type: "unit", unit: "number", value: 0 }
  },
  {
    property: "margin-bottom",
    value: { type: "unit", unit: "number", value: 0 }
  },
  {
    property: "margin-left",
    value: { type: "unit", unit: "number", value: 0 }
  },
  { property: "box-sizing", value: { type: "keyword", value: "border-box" } },
  {
    property: "border-top-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-right-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-bottom-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-left-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  { property: "border-top-style", value: { type: "keyword", value: "solid" } },
  {
    property: "border-right-style",
    value: { type: "keyword", value: "solid" }
  },
  {
    property: "border-bottom-style",
    value: { type: "keyword", value: "solid" }
  },
  { property: "border-left-style", value: { type: "keyword", value: "solid" } }
];
var textarea = input;
var optgroup = [
  { property: "font-family", value: { type: "keyword", value: "inherit" } },
  { property: "font-size", value: { type: "unit", unit: "%", value: 100 } },
  {
    property: "line-height",
    value: { type: "unit", unit: "number", value: 1.15 }
  },
  { property: "margin-top", value: { type: "unit", unit: "number", value: 0 } },
  {
    property: "margin-right",
    value: { type: "unit", unit: "number", value: 0 }
  },
  {
    property: "margin-bottom",
    value: { type: "unit", unit: "number", value: 0 }
  },
  {
    property: "margin-left",
    value: { type: "unit", unit: "number", value: 0 }
  },
  { property: "box-sizing", value: { type: "keyword", value: "border-box" } },
  {
    property: "border-top-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-right-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-bottom-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-left-width",
    value: { type: "unit", unit: "px", value: 1 }
  }
];
var radio = [
  { property: "font-family", value: { type: "keyword", value: "inherit" } },
  { property: "font-size", value: { type: "unit", unit: "%", value: 100 } },
  {
    property: "line-height",
    value: { type: "unit", unit: "number", value: 1.15 }
  },
  { property: "margin-top", value: { type: "unit", unit: "number", value: 0 } },
  {
    property: "margin-right",
    value: { type: "unit", unit: "number", value: 0 }
  },
  {
    property: "margin-bottom",
    value: { type: "unit", unit: "number", value: 0 }
  },
  {
    property: "margin-left",
    value: { type: "unit", unit: "number", value: 0 }
  },
  { property: "box-sizing", value: { type: "keyword", value: "border-box" } },
  {
    property: "border-top-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-right-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-bottom-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-left-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  { property: "border-top-style", value: { type: "keyword", value: "none" } },
  { property: "border-right-style", value: { type: "keyword", value: "none" } },
  {
    property: "border-bottom-style",
    value: { type: "keyword", value: "none" }
  },
  { property: "border-left-style", value: { type: "keyword", value: "none" } }
];
var checkbox = radio;
var button = [
  { property: "font-family", value: { type: "keyword", value: "inherit" } },
  { property: "font-size", value: { type: "unit", unit: "%", value: 100 } },
  {
    property: "line-height",
    value: { type: "unit", unit: "number", value: 1.15 }
  },
  { property: "margin-top", value: { type: "unit", unit: "number", value: 0 } },
  {
    property: "margin-right",
    value: { type: "unit", unit: "number", value: 0 }
  },
  {
    property: "margin-bottom",
    value: { type: "unit", unit: "number", value: 0 }
  },
  {
    property: "margin-left",
    value: { type: "unit", unit: "number", value: 0 }
  },
  { property: "box-sizing", value: { type: "keyword", value: "border-box" } },
  {
    property: "border-top-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-right-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-bottom-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-left-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  { property: "border-top-style", value: { type: "keyword", value: "solid" } },
  {
    property: "border-right-style",
    value: { type: "keyword", value: "solid" }
  },
  {
    property: "border-bottom-style",
    value: { type: "keyword", value: "solid" }
  },
  { property: "border-left-style", value: { type: "keyword", value: "solid" } },
  { property: "text-transform", value: { type: "keyword", value: "none" } }
];
var select = button;
var legend = [
  {
    property: "padding-top",
    value: { type: "unit", unit: "number", value: 0 }
  },
  {
    property: "padding-right",
    value: { type: "unit", unit: "number", value: 0 }
  },
  {
    property: "padding-bottom",
    value: { type: "unit", unit: "number", value: 0 }
  },
  {
    property: "padding-left",
    value: { type: "unit", unit: "number", value: 0 }
  },
  { property: "box-sizing", value: { type: "keyword", value: "border-box" } },
  {
    property: "border-top-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-right-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-bottom-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-left-width",
    value: { type: "unit", unit: "px", value: 1 }
  }
];
var progress = [
  { property: "vertical-align", value: { type: "keyword", value: "baseline" } },
  { property: "box-sizing", value: { type: "keyword", value: "border-box" } },
  {
    property: "border-top-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-right-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-bottom-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-left-width",
    value: { type: "unit", unit: "px", value: 1 }
  }
];
var summary = [
  { property: "display", value: { type: "keyword", value: "list-item" } },
  { property: "box-sizing", value: { type: "keyword", value: "border-box" } },
  {
    property: "border-top-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-right-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-bottom-width",
    value: { type: "unit", unit: "px", value: 1 }
  },
  {
    property: "border-left-width",
    value: { type: "unit", unit: "px", value: 1 }
  }
];

// src/runtime.ts
var tagProperty = "data-ws-tag";

// src/__generated__/tags.ts
var tags = [
  "div",
  "span",
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "map",
  "mark",
  "menu",
  "meter",
  "nav",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "search",
  "section",
  "select",
  "slot",
  "small",
  "source",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  "svg",
  "g",
  "defs",
  "desc",
  "symbol",
  "use",
  "image",
  "switch",
  "path",
  "rect",
  "circle",
  "ellipse",
  "line",
  "polyline",
  "polygon",
  "text",
  "tspan",
  "textPath",
  "marker",
  "linearGradient",
  "radialGradient",
  "stop",
  "pattern",
  "clipPath",
  "mask",
  "filter",
  "feDistantLight",
  "fePointLight",
  "feSpotLight",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feFuncR",
  "feFuncG",
  "feFuncB",
  "feFuncA",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feFlood",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "feSpecularLighting",
  "feTile",
  "feTurbulence",
  "view",
  "animate",
  "set",
  "animateMotion",
  "mpath",
  "animateTransform",
  "metadata",
  "foreignObject"
];

// src/core-metas.ts
var rootComponent = "ws:root";
var rootMeta = {
  label: "Global Root",
  icon: SettingsIcon,
  presetStyle: {
    html
  }
};
var elementComponent = "ws:element";
var elementMeta = {
  label: "Element",
  // convert [object Module] to [object Object] to enable structured cloning
  presetStyle: { ...normalize_css_exports },
  initialProps: [tagProperty, "id", "class"],
  props: {
    [tagProperty]: {
      type: "string",
      control: "tag",
      required: true,
      options: tags
    }
  }
};
var portalComponent = "Slot";
var collectionComponent = "ws:collection";
var collectionMeta = {
  label: "Collection",
  icon: ListViewIcon,
  contentModel: {
    category: "instance",
    children: ["instance"]
  },
  initialProps: ["data"],
  props: {
    data: {
      required: true,
      control: "json",
      type: "json"
    }
  }
};
var descendantComponent = "ws:descendant";
var descendantMeta = {
  label: "Descendant",
  icon: PaintBrushIcon,
  contentModel: {
    category: "none",
    children: []
  },
  // @todo infer possible presets
  presetStyle: {},
  initialProps: ["selector"],
  props: {
    selector: {
      required: true,
      type: "string",
      control: "select",
      options: [
        " p",
        " h1",
        " h2",
        " h3",
        " h4",
        " h5",
        " h6",
        " :where(strong, b)",
        " :where(em, i)",
        " a",
        " img",
        " blockquote",
        " code",
        " :where(ul, ol)",
        " li",
        " hr"
      ]
    }
  }
};
var blockComponent = "ws:block";
var blockTemplateComponent = "ws:block-template";
var blockTemplateMeta = {
  icon: AddTemplateInstanceIcon,
  contentModel: {
    category: "none",
    children: ["instance"]
  }
};
var blockMeta = {
  label: "Content Block",
  icon: ContentBlockIcon,
  contentModel: {
    category: "instance",
    children: [blockTemplateComponent, "instance"]
  }
};
var coreMetas = {
  [rootComponent]: rootMeta,
  [elementComponent]: elementMeta,
  [collectionComponent]: collectionMeta,
  [descendantComponent]: descendantMeta,
  [blockComponent]: blockMeta,
  [blockTemplateComponent]: blockTemplateMeta
};
var isCoreComponent = (component) => component === rootComponent || component === elementComponent || component === collectionComponent || component === descendantComponent || component === blockComponent || component === blockTemplateComponent;
var isComponentDetachable = (component) => component !== rootComponent && component !== blockTemplateComponent && component !== descendantComponent;

// src/instances-utils.ts
var ROOT_INSTANCE_ID = ":root";
var traverseInstances = (instances, instanceId, callback) => {
  const instance = instances.get(instanceId);
  if (instance === void 0) {
    return;
  }
  const skipTraversingChildren = callback(instance);
  if (skipTraversingChildren === false) {
    return;
  }
  for (const child of instance.children) {
    if (child.type === "id") {
      traverseInstances(instances, child.value, callback);
    }
  }
};
var findTreeInstanceIds = (instances, rootInstanceId) => {
  const ids = /* @__PURE__ */ new Set([rootInstanceId]);
  traverseInstances(instances, rootInstanceId, (instance) => {
    ids.add(instance.id);
  });
  return ids;
};
var findTreeInstanceIdsExcludingSlotDescendants = (instances, rootInstanceId) => {
  const ids = /* @__PURE__ */ new Set([rootInstanceId]);
  traverseInstances(instances, rootInstanceId, (instance) => {
    ids.add(instance.id);
    if (instance.component === "Slot") {
      return false;
    }
  });
  return ids;
};
var parseComponentName = (componentName) => {
  const parts = componentName.split(":");
  let namespace;
  let name;
  if (parts.length === 1) {
    [name] = parts;
  } else {
    [namespace, name] = parts;
  }
  return [namespace, name];
};
var getIndexesWithinAncestors = (metas, instances, rootIds) => {
  const ancestors = /* @__PURE__ */ new Set();
  for (const meta of metas.values()) {
    if (meta.indexWithinAncestor !== void 0) {
      ancestors.add(meta.indexWithinAncestor);
    }
  }
  const indexes = /* @__PURE__ */ new Map();
  const traverseInstances2 = (instances2, instanceId, latestIndexes2 = /* @__PURE__ */ new Map()) => {
    const instance = instances2.get(instanceId);
    if (instance === void 0) {
      return;
    }
    const meta = metas.get(instance.component);
    if (ancestors.has(instance.component)) {
      latestIndexes2 = new Map(latestIndexes2);
      latestIndexes2.set(instance.component, /* @__PURE__ */ new Map());
    }
    if (instance.component === blockTemplateComponent) {
      latestIndexes2 = new Map(latestIndexes2);
      for (const key of latestIndexes2.keys()) {
        latestIndexes2.set(key, /* @__PURE__ */ new Map());
      }
    }
    if (meta?.indexWithinAncestor !== void 0) {
      const ancestorIndexes = latestIndexes2.get(meta.indexWithinAncestor);
      if (ancestorIndexes) {
        let index = ancestorIndexes.get(instance.component) ?? -1;
        index += 1;
        ancestorIndexes.set(instance.component, index);
        indexes.set(instance.id, index);
      }
    }
    for (const child of instance.children) {
      if (child.type === "id") {
        traverseInstances2(instances2, child.value, latestIndexes2);
      }
    }
  };
  const latestIndexes = /* @__PURE__ */ new Map();
  for (const instanceId of rootIds) {
    traverseInstances2(instances, instanceId, latestIndexes);
  }
  return indexes;
};

// src/expression.ts
import {
  parse,
  parseExpressionAt
} from "acorn";
import { simple } from "acorn-walk";
var SYSTEM_VARIABLE_ID = ":system";
var systemParameter = {
  id: SYSTEM_VARIABLE_ID,
  scopeInstanceId: ROOT_INSTANCE_ID,
  type: "parameter",
  name: "system"
};
var lintExpression = ({
  expression,
  availableVariables = /* @__PURE__ */ new Set(),
  allowAssignment = false
}) => {
  const diagnostics = [];
  const addMessage = (message, severity = "error") => {
    return (node) => {
      diagnostics.push({
        // tune error position after wrapping expression with parentheses
        from: node.start - 1,
        to: node.end - 1,
        severity,
        message
      });
    };
  };
  if (expression.trim().length === 0) {
    diagnostics.push({
      from: 0,
      to: 0,
      severity: "error",
      message: "Expression cannot be empty"
    });
    return diagnostics;
  }
  try {
    const root = parse(`(${expression})`, {
      ecmaVersion: "latest",
      // support parsing import to forbid explicitly
      sourceType: "module"
    });
    simple(root, {
      Identifier(node) {
        if (availableVariables.has(node.name) === false) {
          addMessage(
            `"${node.name}" is not defined in the scope`,
            "warning"
          )(node);
        }
      },
      Literal() {
      },
      ArrayExpression() {
      },
      ObjectExpression() {
      },
      UnaryExpression() {
      },
      BinaryExpression() {
      },
      LogicalExpression() {
      },
      MemberExpression() {
      },
      ConditionalExpression() {
      },
      TemplateLiteral() {
      },
      ChainExpression() {
      },
      ParenthesizedExpression() {
      },
      AssignmentExpression(node) {
        if (allowAssignment === false) {
          addMessage("Assignment is supported only inside actions")(node);
          return;
        }
        simple(node.left, {
          Identifier(node2) {
            if (availableVariables.has(node2.name) === false) {
              addMessage(
                `"${node2.name}" is not defined in the scope`,
                "warning"
              )(node2);
            }
          }
        });
      },
      // parser forbids to yield inside module
      YieldExpression() {
      },
      ThisExpression: addMessage(`"this" keyword is not supported`),
      FunctionExpression: addMessage("Functions are not supported"),
      UpdateExpression: addMessage("Increment and decrement are not supported"),
      CallExpression: addMessage("Functions are not supported"),
      NewExpression: addMessage("Classes are not supported"),
      SequenceExpression: addMessage(`Only single expression is supported`),
      ArrowFunctionExpression: addMessage("Functions are not supported"),
      TaggedTemplateExpression: addMessage("Tagged template is not supported"),
      ClassExpression: addMessage("Classes are not supported"),
      MetaProperty: addMessage("Imports are not supported"),
      AwaitExpression: addMessage(`"await" keyword is not supported`),
      ImportExpression: addMessage("Imports are not supported")
    });
  } catch (error) {
    const castedError = error;
    diagnostics.push({
      // tune error position after wrapping expression with parentheses
      from: castedError.pos - 1,
      to: castedError.pos - 1,
      severity: "error",
      // trim auto generated error location
      // to not conflict with tuned position
      message: castedError.message.replaceAll(/\s+\(\d+:\d+\)$/g, "")
    });
  }
  return diagnostics;
};
var isLiteralNode = (node) => {
  if (node.type === "Identifier" && node.name === "undefined") {
    return true;
  }
  if (node.type === "Literal") {
    return true;
  }
  if (node.type === "ArrayExpression") {
    return node.elements.every((node2) => {
      if (node2 === null || node2.type === "SpreadElement") {
        return false;
      }
      return isLiteralNode(node2);
    });
  }
  if (node.type === "ObjectExpression") {
    return node.properties.every((property) => {
      if (property.type === "SpreadElement") {
        return false;
      }
      const key = property.key;
      const isIdentifierKey = key.type === "Identifier" && property.computed === false;
      const isLiteralKey = key.type === "Literal";
      return (isLiteralKey || isIdentifierKey) && isLiteralNode(property.value);
    });
  }
  return false;
};
var isLiteralExpression = (expression) => {
  try {
    const node = parseExpressionAt(expression, 0, { ecmaVersion: "latest" });
    return isLiteralNode(node);
  } catch {
    return false;
  }
};
var getExpressionIdentifiers = (expression) => {
  const identifiers2 = /* @__PURE__ */ new Set();
  try {
    const root = parseExpressionAt(expression, 0, { ecmaVersion: "latest" });
    simple(root, {
      Identifier: (node) => identifiers2.add(node.name),
      AssignmentExpression(node) {
        simple(node.left, {
          Identifier: (node2) => identifiers2.add(node2.name)
        });
      }
    });
  } catch {
  }
  return identifiers2;
};
var transpileExpression = ({
  expression,
  executable = false,
  replaceVariable
}) => {
  let root;
  try {
    root = parseExpressionAt(expression, 0, { ecmaVersion: "latest" });
  } catch (error) {
    const message = error.message;
    throw Error(`${message} in ${JSON.stringify(expression)}`);
  }
  const replacements = [];
  const replaceIdentifier = (node, assignee) => {
    const newName = replaceVariable?.(node.name, assignee);
    if (newName) {
      replacements.push([node.start, node.end, newName]);
    }
  };
  simple(root, {
    Identifier: (node) => replaceIdentifier(node, false),
    AssignmentExpression(node) {
      simple(node.left, {
        Identifier: (node2) => replaceIdentifier(node2, true)
      });
    },
    MemberExpression(node) {
      if (executable === false || node.optional) {
        return;
      }
      if (node.computed === false) {
        const dotIndex = expression.indexOf(".", node.object.end);
        replacements.push([dotIndex, dotIndex, "?"]);
      }
      if (node.computed === true) {
        const dotIndex = expression.indexOf("[", node.object.end);
        replacements.push([dotIndex, dotIndex, "?."]);
      }
    }
  });
  replacements.sort(([leftStart], [rightStart]) => rightStart - leftStart);
  for (const [start, end, fragment] of replacements) {
    const before = expression.slice(0, start);
    const after = expression.slice(end);
    expression = before + fragment + after;
  }
  return expression;
};
var parseObjectExpression = (expression) => {
  const map = /* @__PURE__ */ new Map();
  let root;
  try {
    root = parseExpressionAt(expression, 0, { ecmaVersion: "latest" });
  } catch (error) {
    return map;
  }
  if (root.type !== "ObjectExpression") {
    return map;
  }
  for (const property of root.properties) {
    if (property.type === "SpreadElement") {
      continue;
    }
    if (property.computed) {
      continue;
    }
    let key;
    if (property.key.type === "Identifier") {
      key = property.key.name;
    } else if (property.key.type === "Literal" && typeof property.key.value === "string") {
      key = property.key.value;
    } else {
      continue;
    }
    const valueExpression = expression.slice(
      property.value.start,
      property.value.end
    );
    map.set(key, valueExpression);
  }
  return map;
};
var generateObjectExpression = (map) => {
  let generated = "{\n";
  for (const [key, valueExpression] of map) {
    const keyExpression = JSON.stringify(key);
    generated += `  ${keyExpression}: ${valueExpression},
`;
  }
  generated += `}`;
  return generated;
};
var dataSourceVariablePrefix = "$ws$dataSource$";
var encodeDataVariableId = (id) => {
  if (id === SYSTEM_VARIABLE_ID) {
    return "$ws$system";
  }
  const encoded = id.replaceAll("-", "__DASH__");
  return `${dataSourceVariablePrefix}${encoded}`;
};
var decodeDataVariableId = (name) => {
  if (name === "$ws$system") {
    return SYSTEM_VARIABLE_ID;
  }
  if (name.startsWith(dataSourceVariablePrefix)) {
    const encoded = name.slice(dataSourceVariablePrefix.length);
    return encoded.replaceAll("__DASH__", "-");
  }
  return;
};
var generateExpression = ({
  expression,
  dataSources,
  usedDataSources,
  scope
}) => {
  return transpileExpression({
    expression,
    executable: true,
    replaceVariable: (identifier) => {
      const depId = decodeDataVariableId(identifier);
      let dep = depId ? dataSources.get(depId) : void 0;
      if (depId === SYSTEM_VARIABLE_ID) {
        dep = systemParameter;
      }
      if (dep) {
        usedDataSources?.set(dep.id, dep);
        return scope.getName(dep.id, dep.name);
      }
      return "undefined";
    }
  });
};
var executeExpression = (expression) => {
  try {
    const fn = new Function(`return (${expression})`);
    return fn();
  } catch {
  }
};

// src/url-pattern.ts
var tokenRegex = /:(?<name>\w+)(?<modifier>[?*]?)|(?<wildcard>(?<!:\w+)\*)/;
var isPathnamePattern = (pathname) => tokenRegex.test(pathname);
var tokenRegexGlobal = new RegExp(tokenRegex.source, "g");
var matchPathnameParams = (pathname) => {
  return pathname.matchAll(tokenRegexGlobal);
};

// src/page-utils.ts
var ROOT_FOLDER_ID = "root";
var isRootFolder = ({ id }) => id === ROOT_FOLDER_ID;
var findPageByIdOrPath = (idOrPath, pages) => {
  if (idOrPath === "" || idOrPath === "/" || idOrPath === pages.homePage.id) {
    return pages.homePage;
  }
  return pages.pages.find(
    (page) => page.id === idOrPath || getPagePath(page.id, pages) === idOrPath
  );
};
var findParentFolderByChildId = (id, folders) => {
  for (const folder of folders) {
    if (folder.children.includes(id)) {
      return folder;
    }
  }
};
var getPagePath = (id, pages) => {
  const foldersMap = /* @__PURE__ */ new Map();
  const childParentMap = /* @__PURE__ */ new Map();
  for (const folder of pages.folders) {
    foldersMap.set(folder.id, folder);
    for (const childId of folder.children) {
      childParentMap.set(childId, folder.id);
    }
  }
  const paths = [];
  let currentId = id;
  const allPages = [pages.homePage, ...pages.pages];
  for (const page of allPages) {
    if (page.id === id) {
      paths.push(page.path);
      currentId = childParentMap.get(page.id);
      break;
    }
  }
  while (currentId) {
    const folder = foldersMap.get(currentId);
    if (folder === void 0) {
      break;
    }
    paths.push(folder.slug);
    currentId = childParentMap.get(currentId);
  }
  return paths.reverse().join("/").replace(/\/+/g, "/");
};
var getStaticSiteMapXml = (pages, updatedAt) => {
  const allPages = [pages.homePage, ...pages.pages];
  return allPages.filter((page) => (page.meta.documentType ?? "html") === "html").filter(
    (page) => executeExpression(page.meta.excludePageFromSearch) !== true
  ).filter((page) => false === isPathnamePattern(page.path)).map((page) => ({
    path: getPagePath(page.id, pages),
    lastModified: updatedAt.split("T")[0]
  }));
};

// src/scope.ts
import reservedIdentifiers from "reserved-identifiers";
var identifiers = reservedIdentifiers({ includeGlobalProperties: true });
var isReserved = (identifier) => identifiers.has(identifier);
var normalizeJsName = (name) => {
  name = name.replaceAll(/[^\w$]/g, "");
  if (name.length === 0) {
    return "_";
  }
  if (/[A-Za-z_$]/.test(name[0]) === false) {
    name = `_${name}`;
  }
  if (isReserved(name)) {
    return `${name}_`;
  }
  return name;
};
var createScope = (occupiedIdentifiers = [], normalizeName = normalizeJsName, separator = "_") => {
  const nameById = /* @__PURE__ */ new Map();
  const usedNames = /* @__PURE__ */ new Set();
  for (const identifier of occupiedIdentifiers) {
    usedNames.add(identifier);
  }
  const getName = (id, preferredName) => {
    const cachedName = nameById.get(id);
    if (cachedName !== void 0) {
      return cachedName;
    }
    preferredName = normalizeName(preferredName);
    let index = 0;
    let scopedName = preferredName;
    while (usedNames.has(scopedName)) {
      index += 1;
      scopedName = `${preferredName}${separator}${index}`;
    }
    nameById.set(id, scopedName);
    usedNames.add(scopedName);
    return scopedName;
  };
  return {
    getName
  };
};

// src/resources-generator.ts
var generateResources = ({
  scope,
  page,
  dataSources,
  props,
  resources
}) => {
  const usedDataSources = /* @__PURE__ */ new Map();
  let generatedRequests = "";
  for (const resource of resources.values()) {
    let generatedRequest = "";
    const resourceName = scope.getName(resource.id, resource.name);
    generatedRequest += `  const ${resourceName}: ResourceRequest = {
`;
    generatedRequest += `    name: ${JSON.stringify(resource.name)},
`;
    const url = generateExpression({
      expression: resource.url,
      dataSources,
      usedDataSources,
      scope
    });
    generatedRequest += `    url: ${url},
`;
    generatedRequest += `    searchParams: [
`;
    for (const searchParam of resource.searchParams ?? []) {
      const value = generateExpression({
        expression: searchParam.value,
        dataSources,
        usedDataSources,
        scope
      });
      generatedRequest += `      { name: "${searchParam.name}", value: ${value} },
`;
    }
    generatedRequest += `    ],
`;
    generatedRequest += `    method: "${resource.method}",
`;
    generatedRequest += `    headers: [
`;
    for (const header2 of resource.headers) {
      const value = generateExpression({
        expression: header2.value,
        dataSources,
        usedDataSources,
        scope
      });
      generatedRequest += `      { name: "${header2.name}", value: ${value} },
`;
    }
    generatedRequest += `    ],
`;
    if (resource.body !== void 0 && resource.body.length > 0) {
      const body2 = generateExpression({
        expression: resource.body,
        dataSources,
        usedDataSources,
        scope
      });
      generatedRequest += `    body: ${body2},
`;
    }
    generatedRequest += `  }
`;
    generatedRequests += generatedRequest;
  }
  let generatedVariables = "";
  for (const dataSource of usedDataSources.values()) {
    if (dataSource.type === "variable") {
      const name = scope.getName(dataSource.id, dataSource.name);
      const value = JSON.stringify(dataSource.value.value);
      generatedVariables += `  let ${name} = ${value}
`;
    }
    if (dataSource.type === "parameter") {
      if (dataSource.id === page.systemDataSourceId || dataSource.id === SYSTEM_VARIABLE_ID) {
        const name = scope.getName(dataSource.id, dataSource.name);
        generatedVariables += `  const ${name} = _props.system
`;
      }
    }
  }
  let generated = "";
  generated += `import type { System, ResourceRequest } from "@webstudio-is/sdk";
`;
  generated += `export const getResources = (_props: { system: System }) => {
`;
  generated += generatedVariables;
  generated += generatedRequests;
  generated += `  const _data = new Map<string, ResourceRequest>([
`;
  for (const dataSource of dataSources.values()) {
    if (dataSource.type === "resource") {
      const name = scope.getName(dataSource.resourceId, dataSource.name);
      generated += `    ["${name}", ${name}],
`;
    }
  }
  generated += `  ])
`;
  generated += `  const _action = new Map<string, ResourceRequest>([
`;
  for (const prop of props.values()) {
    if (prop.type === "resource") {
      const name = scope.getName(prop.value, prop.name);
      generated += `    ["${name}", ${name}],
`;
    }
  }
  generated += `  ])
`;
  generated += `  return { data: _data, action: _action }
`;
  generated += `}
`;
  return generated;
};
var getMethod = (value) => {
  switch (value?.toLowerCase()) {
    case "get":
      return "get";
    case "delete":
      return "delete";
    case "put":
      return "put";
    default:
      return "post";
  }
};
var replaceFormActionsWithResources = ({
  props,
  instances,
  resources
}) => {
  const formProps = /* @__PURE__ */ new Map();
  for (const prop of props.values()) {
    if (prop.name === "method" && prop.type === "string" && instances.get(prop.instanceId)?.component === "Form") {
      let data = formProps.get(prop.instanceId);
      if (data === void 0) {
        data = {};
        formProps.set(prop.instanceId, data);
      }
      data.method = prop.value;
      props.delete(prop.id);
    }
    if (prop.name === "action" && prop.type === "string" && prop.value && instances.get(prop.instanceId)?.component === "Form") {
      let data = formProps.get(prop.instanceId);
      if (data === void 0) {
        data = {};
        formProps.set(prop.instanceId, data);
      }
      data.action = prop.value;
      props.set(prop.id, {
        id: prop.id,
        instanceId: prop.instanceId,
        name: prop.name,
        type: "resource",
        value: prop.instanceId
      });
    }
  }
  for (const [instanceId, { action, method }] of formProps) {
    if (action) {
      resources.set(instanceId, {
        id: instanceId,
        name: "action",
        method: getMethod(method),
        url: JSON.stringify(action),
        headers: [
          { name: "Content-Type", value: JSON.stringify("application/json") }
        ]
      });
    }
  }
};

// src/page-meta-generator.ts
var generatePageMeta = ({
  globalScope,
  page,
  dataSources,
  assets
}) => {
  const localScope = createScope(["system", "resources"]);
  const usedDataSources = /* @__PURE__ */ new Map();
  const titleExpression = generateExpression({
    expression: page.title,
    dataSources,
    usedDataSources,
    scope: localScope
  });
  const descriptionExpression = generateExpression({
    expression: page.meta.description ?? "undefined",
    dataSources,
    usedDataSources,
    scope: localScope
  });
  const excludePageFromSearchExpression = generateExpression({
    expression: page.meta.excludePageFromSearch ?? "undefined",
    dataSources,
    usedDataSources,
    scope: localScope
  });
  const languageExpression = generateExpression({
    expression: page.meta.language ?? "undefined",
    dataSources,
    usedDataSources,
    scope: localScope
  });
  const socialImageAssetNameExpression = JSON.stringify(
    page.meta.socialImageAssetId ? assets.get(page.meta.socialImageAssetId)?.name : void 0
  );
  const socialImageUrlExpression = generateExpression({
    expression: page.meta.socialImageUrl ?? "undefined",
    dataSources,
    usedDataSources,
    scope: localScope
  });
  const statusExpression = generateExpression({
    expression: page.meta.status ?? "undefined",
    dataSources,
    usedDataSources,
    scope: localScope
  });
  const redirectExpression = generateExpression({
    expression: page.meta.redirect ?? "undefined",
    dataSources,
    usedDataSources,
    scope: localScope
  });
  let customExpression = "";
  customExpression += `[
`;
  for (const customMeta of page.meta.custom ?? []) {
    if (customMeta.property.trim().length === 0) {
      continue;
    }
    const propertyExpression = JSON.stringify(customMeta.property);
    const contentExpression = generateExpression({
      expression: customMeta.content,
      dataSources,
      usedDataSources,
      scope: localScope
    });
    customExpression += `      {
`;
    customExpression += `        property: ${propertyExpression},
`;
    customExpression += `        content: ${contentExpression},
`;
    customExpression += `      },
`;
  }
  customExpression += `    ]`;
  let generated = "";
  generated += `export const getPageMeta = ({
`;
  generated += `  system,
`;
  generated += `  resources,
`;
  generated += `}: {
`;
  generated += `  system: System;
`;
  generated += `  resources: Record<string, any>;
`;
  generated += `}): PageMeta => {
`;
  for (const dataSource of usedDataSources.values()) {
    if (dataSource.type === "variable") {
      const valueName = localScope.getName(dataSource.id, dataSource.name);
      const initialValueString = JSON.stringify(dataSource.value.value);
      generated += `  let ${valueName} = ${initialValueString}
`;
      continue;
    }
    if (dataSource.type === "parameter") {
      if (dataSource.id === page.systemDataSourceId || dataSource.id === SYSTEM_VARIABLE_ID) {
        const valueName = localScope.getName(dataSource.id, dataSource.name);
        generated += `  let ${valueName} = system
`;
      }
      continue;
    }
    if (dataSource.type === "resource") {
      const valueName = localScope.getName(dataSource.id, dataSource.name);
      const resourceName = globalScope.getName(
        dataSource.resourceId,
        dataSource.name
      );
      generated += `  let ${valueName} = resources.${resourceName}
`;
      continue;
    }
  }
  generated += `  return {
`;
  generated += `    title: ${titleExpression},
`;
  generated += `    description: ${descriptionExpression},
`;
  generated += `    excludePageFromSearch: ${excludePageFromSearchExpression},
`;
  generated += `    language: ${languageExpression},
`;
  generated += `    socialImageAssetName: ${socialImageAssetNameExpression},
`;
  generated += `    socialImageUrl: ${socialImageUrlExpression},
`;
  generated += `    status: ${statusExpression},
`;
  generated += `    redirect: ${redirectExpression},
`;
  generated += `    custom: ${customExpression},
`;
  generated += `  };
`;
  generated += `};
`;
  return generated;
};

// src/css.ts
import { kebabCase } from "change-case";
import {
  createRegularStyleSheet,
  generateAtomic
} from "@webstudio-is/css-engine";
import { getFontFaces } from "@webstudio-is/fonts";
var addFontRules = ({
  sheet,
  assets,
  assetBaseUrl
}) => {
  const fontAssets = [];
  for (const asset of assets.values()) {
    if (asset.type === "font") {
      fontAssets.push(asset);
    }
  }
  const fontFaces = getFontFaces(fontAssets, { assetBaseUrl });
  for (const fontFace of fontFaces) {
    sheet.addFontFaceRule(fontFace);
  }
};
var createImageValueTransformer = (assets, { assetBaseUrl }) => (styleValue) => {
  if (styleValue.type === "image" && styleValue.value.type === "asset") {
    const asset = assets.get(styleValue.value.value);
    if (asset === void 0) {
      return { type: "keyword", value: "none" };
    }
    const url = `${assetBaseUrl}${asset.name}`;
    return {
      type: "image",
      value: {
        type: "url",
        url
      },
      hidden: styleValue.hidden
    };
  }
};
var normalizeClassName = (name) => kebabCase(name);
var generateCss = ({
  assets,
  instances,
  props,
  breakpoints,
  styles,
  styleSourceSelections,
  componentMetas,
  assetBaseUrl,
  atomic
}) => {
  const fontSheet = createRegularStyleSheet({ name: "ssr" });
  const presetSheet = createRegularStyleSheet({ name: "ssr" });
  const userSheet = createRegularStyleSheet({ name: "ssr" });
  addFontRules({ sheet: fontSheet, assets, assetBaseUrl });
  presetSheet.addMediaRule("presets");
  const presetClasses = /* @__PURE__ */ new Map();
  const scope = createScope([], normalizeClassName, "-");
  const tagsByComponent = /* @__PURE__ */ new Map();
  tagsByComponent.set(rootComponent, /* @__PURE__ */ new Set(["html"]));
  const tagByInstanceId = /* @__PURE__ */ new Map();
  for (const prop of props.values()) {
    if (prop.type === "string" && prop.name === "tag") {
      tagByInstanceId.set(prop.instanceId, prop.value);
    }
  }
  for (const instance of instances.values()) {
    const propTag = tagByInstanceId.get(instance.id);
    const meta = componentMetas.get(instance.component);
    const metaTag = Object.keys(meta?.presetStyle ?? {}).at(0);
    let componentTags = tagsByComponent.get(instance.component);
    if (componentTags === void 0) {
      componentTags = /* @__PURE__ */ new Set();
      tagsByComponent.set(instance.component, componentTags);
    }
    const tag = instance.tag ?? propTag ?? metaTag;
    if (tag) {
      componentTags.add(tag);
    }
  }
  for (const [component, meta] of componentMetas) {
    const componentTags = tagsByComponent.get(component);
    const [_namespace, componentName] = parseComponentName(component);
    const className = `w-${scope.getName(component, meta.label ?? componentName)}`;
    const presetStyle = Object.entries(meta.presetStyle ?? {});
    if (presetStyle.length > 0) {
      presetClasses.set(component, className);
    }
    for (const [tag, styles2] of presetStyle) {
      if (!componentTags?.has(tag)) {
        continue;
      }
      const selector = component === rootComponent ? ":root" : `${tag}.${className}`;
      const rule = presetSheet.addNestingRule(selector);
      for (const declaration of styles2) {
        rule.setDeclaration({
          breakpoint: "presets",
          selector: declaration.state ?? "",
          property: declaration.property,
          value: declaration.value
        });
      }
    }
  }
  for (const breakpoint of breakpoints.values()) {
    userSheet.addMediaRule(breakpoint.id, breakpoint);
  }
  const imageValueTransformer = createImageValueTransformer(assets, {
    assetBaseUrl
  });
  userSheet.setTransformer(imageValueTransformer);
  for (const styleDecl of styles.values()) {
    const rule = userSheet.addMixinRule(styleDecl.styleSourceId);
    rule.setDeclaration({
      breakpoint: styleDecl.breakpointId,
      selector: styleDecl.state ?? "",
      property: styleDecl.property,
      value: styleDecl.value
    });
  }
  const classes = /* @__PURE__ */ new Map();
  const parentIdByInstanceId = /* @__PURE__ */ new Map();
  for (const instance of instances.values()) {
    const presetClass = presetClasses.get(instance.component);
    if (presetClass) {
      classes.set(instance.id, [presetClass]);
    }
    for (const child of instance.children) {
      if (child.type === "id") {
        parentIdByInstanceId.set(child.value, instance.id);
      }
    }
  }
  const descendantSelectorByInstanceId = /* @__PURE__ */ new Map();
  for (const prop of props.values()) {
    if (prop.name === "selector" && prop.type === "string") {
      descendantSelectorByInstanceId.set(prop.instanceId, prop.value);
    }
  }
  const instanceByRule = /* @__PURE__ */ new Map();
  for (const selection of styleSourceSelections.values()) {
    let { instanceId } = selection;
    const { values } = selection;
    if (instanceId === ROOT_INSTANCE_ID) {
      const rule2 = userSheet.addNestingRule(`:root`);
      rule2.applyMixins(values);
      continue;
    }
    let descendantSuffix = "";
    const instance = instances.get(instanceId);
    if (instance === void 0) {
      continue;
    }
    if (instance.component === descendantComponent) {
      const parentId = parentIdByInstanceId.get(instanceId);
      const descendantSelector = descendantSelectorByInstanceId.get(instanceId);
      if (parentId && descendantSelector) {
        descendantSuffix = descendantSelector;
        instanceId = parentId;
      }
    }
    const meta = componentMetas.get(instance.component);
    const [_namespace, shortName] = parseComponentName(instance.component);
    const baseName = instance.label ?? meta?.label ?? shortName;
    const className = `w-${scope.getName(instanceId, baseName)}`;
    if (atomic === false) {
      let classList = classes.get(instanceId);
      if (classList === void 0) {
        classList = [];
        classes.set(instanceId, classList);
      }
      classList.push(className);
    }
    const rule = userSheet.addNestingRule(`.${className}`, descendantSuffix);
    rule.applyMixins(values);
    instanceByRule.set(rule, instanceId);
  }
  const fontCss = fontSheet.cssText;
  const presetCss = presetSheet.cssText.replaceAll(
    "@media all ",
    "@layer presets "
  );
  if (atomic) {
    const { cssText } = generateAtomic(userSheet, {
      getKey: (rule) => instanceByRule.get(rule),
      transformValue: imageValueTransformer,
      classes
    });
    return {
      cssText: `${fontCss}${presetCss}
${cssText}`,
      classes
    };
  }
  return {
    cssText: `${fontCss}${presetCss}
${userSheet.cssText}`,
    classes
  };
};
export {
  Asset,
  Assets,
  Breakpoint,
  Breakpoints,
  CompilerSettings,
  ComponentState,
  ContentModel,
  DataSource,
  DataSourceVariableValue,
  DataSources,
  Deployment,
  ExpressionChild,
  Folder,
  FolderName,
  FontAsset,
  HomePagePath,
  IdChild,
  ImageAsset,
  ImageMeta,
  Instance,
  InstanceChild,
  Instances,
  OldPagePath,
  PageName,
  PagePath,
  PageRedirect,
  PageTitle,
  Pages,
  PresetStyleDecl,
  ProjectNewRedirectPath,
  Prop,
  PropMeta,
  Props,
  RANGE_UNITS,
  ROOT_FOLDER_ID,
  ROOT_INSTANCE_ID,
  Resource,
  ResourceRequest,
  Resources,
  SYSTEM_VARIABLE_ID,
  StyleDecl,
  StyleSource,
  StyleSourceSelection,
  StyleSourceSelections,
  StyleSources,
  Styles,
  Templates,
  TextChild,
  WebstudioFragment,
  WsComponentMeta,
  addFontRules,
  animationActionSchema,
  animationKeyframeSchema,
  blockComponent,
  blockTemplateComponent,
  blockTemplateMeta,
  collectionComponent,
  componentCategories,
  coreMetas,
  createImageValueTransformer,
  createScope,
  decodeDataVariableId as decodeDataSourceVariable,
  decodeDataVariableId,
  descendantComponent,
  documentTypes,
  durationUnitValueSchema,
  elementComponent,
  encodeDataVariableId as encodeDataSourceVariable,
  encodeDataVariableId,
  executeExpression,
  findPageByIdOrPath,
  findParentFolderByChildId,
  findTreeInstanceIds,
  findTreeInstanceIdsExcludingSlotDescendants,
  generateCss,
  generateExpression,
  generateObjectExpression,
  generatePageMeta,
  generateResources,
  getExpressionIdentifiers,
  getIndexesWithinAncestors,
  getPagePath,
  getStaticSiteMapXml,
  getStyleDeclKey,
  initialBreakpoints,
  insetUnitValueSchema,
  isComponentDetachable,
  isCoreComponent,
  isLiteralExpression,
  isPathnamePattern,
  isRootFolder,
  lintExpression,
  matchPathnameParams,
  parseComponentName,
  parseObjectExpression,
  portalComponent,
  rangeUnitValueSchema,
  replaceFormActionsWithResources,
  rootComponent,
  scrollAnimationSchema,
  systemParameter,
  tags,
  transpileExpression,
  viewAnimationSchema
};
